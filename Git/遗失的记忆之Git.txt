git commit -am "<discribe>"				跳过git add，直接将所有已经跟踪过的文件暂存起来，提交到仓库

cat <file>						查看文件<file>内容
git diff <commitId> -- <file>				查看当前工作的file与<commitId>的那个版本下这个文件的差别
git diff <commitId>					查看当前工作区与<commitId>的那个版本下所有文件的差别
git diff --cached					特指查看暂存区和分支的比较
git diff --staged					特指查看暂存区和分支的比较，Git1.6.1以上可用

git log -p -<number>					查看提交日志，显示每次提交的内容详细差异，并只显示近<number>条数据
git log --stat						查看提交日志，并显示简略的统计信息
git log --pretty=format:"%h - %an, %ar : %s"		查看提交日志，按常用的格式显示:提交对象的简短哈希字串、作者的名字、作者修订日期(按多久以前的方式显示)、提交说明【更多格式元素可以查阅pretty=format常用的选项】

git log --oneline --decorate --graph --all		查看提交日志，按分支图的方式显示，输出提交历史、各分支的指向以及项目的分支分叉情况

git commit --amend					将上次commit与这次暂存区的修改进行合并，重新改写上次的commit，并且能编辑commit的提交信息

git mv <file1> <file2>					将文件file1改名为file2

git checkout -- <file>					让<file>这个文件回到最近一次git commit或git add时的状态
git reset HEAD <file>					让<file>这个文件的暂存区清空

git rm --cached <file|dir|...>				把文件或文件夹从Git仓库中删除，即从暂存区删除，但仍然希望保留在当前工作目录中，又即取消跟踪，类似于.gitignore的作用

git remote add <remoteName> git@github.com:<account>/<repo>.git			将本地仓库(即当前路径下的这个仓库)与github上<account>这个账户下的<repo>仓库进行关联，并将关联的远程仓库命名为<remoteName>，一般默认为origin
git clone 【-<remoteName>】 git@github.com:<account>/<repo>.git 【<filename>】  将github上<account>这个账户下的<repo>仓库复制到当前路径下的这个文件夹中，并进行关联，【可以添加<filename>字段对生成的文件夹进行重命名】，默认的远程仓库名为origin，【可以自己设定远程仓库名<remoteName>】

git push <repo> HEAD --force				强迫删除远程仓库<repo>当前版本之后的commit历史，包括本地仓库，即清空之后的commit历史

git branch -r						查看远程分支
git branch -vv						查看本地分支，并包含更多信息，如每一个分支正在跟踪哪个远程分支与本地分支是否领先、落后等，注意此时的远程分支数据来源于本地缓存的服务器数据，不一定是最新的服务器数据，如果想要与真实最新的远程比较，应该在使用之前抓取所有远程仓库，用git fetch --all
git branch --merge					仅显示已经合并到当前分支的分支
git branch --no-merge					仅显示尚未合并到当前分支的分支

git checkout --track <repo>/<dev>			创建本地同名<dev>分支，并与远程仓库<repo>的<dev>分支链接，然后切换到这个分支，仅在远程仓库<repo>下<dev>存在且本地<dev>未链接时可以使用，等同于git checkout -b <dev> <repo>/<dev>，这是一种简化写法
git branch -u <repo>/<dev>				设定或者修改当前分支正在跟踪的上游远程分支为<repo>/<dev>
git branch --set-upstream <br1> <repo>/<br2>		设定或者修改当前分支<br1>正在跟踪的上游远程分支为<repo>/<br2>

git branch -D <feature>					常用于<feature>分支，丢弃一个没有被合并过的分支，强行删除
git push <repo> --delete <dev>				删除<repo>/<dev>分支，即删除远程服务器<repo>上的<dev>分支

git pull <repo> <dev>					从远程<repo>获取最新版本<dev>并merge到本地同名<dev>
git fetch <repo> <br1>:<br2>				从远程<repo>的<br1>分支下载最新的版本到本地的<br2>分支上，原先<br2>分支为新创建的空分支，一般操作是，后面再将<br2>这个分支与相应的分支进行比较，之后再合并
git fetch <repo> <dev>					从远程<repo>获取最新版本<dev>到本地临时库<repo>/<dev>上，一般操作是，后面git log -p <dev>..<repo>/<dev>进行差异比较，之后再进行合并
git fetch <repo>					获取远程<repo>上所有分支，作为本地缓存的服务器数据

git stash						储存当前内容
git stash apply						恢复之前储存的内容
git stash drop						删除stash储存的内容
git stash pop						恢复的同时也删除stash内容
git stash list						查看stash列表

git show <tagname>					查看相应的标签信息
git tag -a <tagname> -m <discribe> <commitId>		创建带有说明的标签


git tag -d <tagname>					删除<tagname>标签
git push <repo> <tagname>				推送指定标签<tagname>到远程<repo>
git push <repo> --tags					一次性推送全部尚未推送到远程的本地标签
git push <repo> :refs/tags/<tagname>			在先使用git tag -d <tagname>删除一个本地标签的前提下，再使用这个可以删除同名的远程标签<tagname>


git config --global alias.<abbrev> <command>		配置全局别名<abbrev>替换git原先的<command>，配置的文件在用户主目录下的一个隐藏文件.gitconfig中
git config alias.<abbrev> <command>			配置仓库别名<abbrev>替换git原先的<command>，配置的文件在仓库的.git/config中


git remote 						列出已经存在的远程分支
git remote -v						列出已经存在的远程分支的详细信息
git remote show <remote>				列出指定的远程分支的详细信息，其中remote的值是git remote结果中的一个远程分支


git rebase <br>						假设当前分支为master，取出<br>分支上的修改，把master分支作为基础，重绘<br>分支，即把修改在master分支上重演一遍，生成新的一条具备修改且同时基于master分支的<br>分支，称之为衍合。注意其中master分支未变化，一般使用时，再切换到merge，使用merge合并<br>即将修改放置在了master上，但没有出现分叉结构。
git rebase --onto <br1> <br2> <br3>			先执行git checkout <br3>，然后找出<br3>分支、<br2>分支的共同祖先之后的差异；再以<br1>作为基础，重绘<br3>分支，把那些差异在<br1>上重演一遍，生成新的一条具备差异且同时基于<br1>的<br3>分支。注意其中<br1>分支、<br2>分支均未变化，一般使用时，再切换到<br1>，使用merge合并<br1>和新的<br3>即将<br2>与<br3>差异放置在了<br1>上，但没有出现分叉结构。


git revert <commitId>					生成一个新的提交来撤销<commitId>的提交，此次提交之前的commit都会被保留
git reset <commitId>					回到<commitId>的提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区


git rebase -i <repo>/<master>				打开commit处理界面编辑commit历史，操作对象是那些自最后一次从<repo>仓库拉取或者向<repo>推送之后的所有的提交